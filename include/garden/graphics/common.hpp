// Copyright 2022-2024 Nikita Fediuchin. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/***********************************************************************************************************************
 * @file
 * @brief Common graphics functions.
 */

#pragma once
#include "garden/defines.hpp"
#include "math/color.hpp"
#include "math/flags.hpp"

namespace garden::graphics
{

/**
 * @brief Nvidia architecture maximum binary size.
 */
constexpr psize maxPushConstantsSize = 128;

/***********************************************************************************************************************
 * @brief Point where programmable shading occurs.
 * 
 * @details 
 * Each stage is designed to perform a particular set of operations on the data that flows through the 
 * pipeline, allowing for flexible and powerful processing of graphics and compute tasks. 
 * The modern programmable graphics pipeline consists of multiple shader stages, each capable of 
 * running custom shader programs written in shading language.
 */
enum class ShaderStage : uint8
{
	None = 0x00,     /**< No shader stage flags. (0) */
	Vertex = 0x01,   /**< Controls processing of vertex data. */
	Fragment = 0x02, /**< Operates on fragments generated by the rasterization process. */
	Compute = 0x04   /**< Performs general-purpose computing tasks. */
};

/**
 * @brief Rendering pipeline type.
 * 
 * @details
 * Each pipeline type is optimized for a specific set of tasks and operations within the engine, 
 * reflecting the different requirements of rendering graphics and performing compute operations.
 * 
 * @todo Ray-Tracing pipeline support
 */
enum class PipelineType : uint8
{
	Graphics, /**< Designed for rendering operations. */
	Compute,  /**< Designed for compute operations. */
	Count     /**< Pipeline type count. */
};

/**
 * @brief Texture sampling method type.
 * 
 * @details
 * Method used by the GPU to determine the color of a texture sample based on the texture coordinates 
 * provided by a shader. When a texture is sampled in a shader, the texture coordinates might not 
 * directly correspond to the texel (texture pixel) positions in the texture. The sampler filter 
 * type defines how the color value for these coordinates is calculated, affecting the final appearance 
 * of the texture when it's applied to a surface in 3D space. The choice of filter type can 
 * significantly impact both the visual quality and the performance of texture sampling.
 */
enum class SamplerFilter : uint8
{
	Nearest, /**< Selects the color of the closest texel. (nearest-neighbour) */
	Linear,  /**< Computed by linearly interpolating between the colors of adjacent texels. */
	Count,   /**< Sampler filter type count. */
};

/**
 * @brief Rendering command buffer type.
 * 
 * @details 
 * Command buffers are categorized into different types based on their submission and execution behavior. These 
 * types primarily differentiate how command buffers can be used within the rendering and computation processes.
 * 
 * @warning All command buffer types may have several frames delay!
 */
enum class CommandBufferType : uint8
{
	Frame,        /**< Current frame command buffer. */
	Graphics,     /**< Supports graphics, transfer and compute commands. */
	TransferOnly, /**< Supports transfer only commands. */
	ComputeOnly,  /**< Supports compute only commands. */
	AsyncCompute, /**< Async compute command buffer, same support as compute. */
	Count         /**< Command buffer type count. */
};

/**
 * @brief Shader stage type count.
 */
#define SHADER_STAGE_COUNT 3

DECLARE_ENUM_CLASS_FLAG_OPERATORS(ShaderStage)

/***********************************************************************************************************************
 * @brief Pipeline type name strings.
 */
constexpr string_view pipelineTypeNames[(psize)PipelineType::Count] =
{
	"Graphics", "Compute"
};
/**
 * @brief Sampler filter name strings.
 */
constexpr string_view samplerFilterNames[(psize)SamplerFilter::Count] =
{
	"Nearest", "Linear"
};

/**
 * @brief Returns pipeline type.
 * @param pipelineType target pipeline type name (camelCase)
 * @throw runtime_error on unknown pipeline type.
 */
static PipelineType toPipelineType(string_view pipelineType)
{
	if (pipelineType == "graphics") return PipelineType::Graphics;
	if (pipelineType == "compute") return PipelineType::Compute;
	throw runtime_error("Unknown pipeline type. (" + string(pipelineType) + ")");
}
/**
 * @brief Returns pipeline type name string.
 * @param pipelineType target pipeline type
 */
static string_view toString(PipelineType pipelineType) noexcept
{
	GARDEN_ASSERT((uint8)pipelineType < (uint8)PipelineType::Count);
	return pipelineTypeNames[(psize)pipelineType];
}

/**
 * @brief Returns sampler filter type.
 * @param samplerFilter target sampler filter name (camelCase)
 * @throw runtime_error on unknown sampler filter type.
 */
static SamplerFilter toSamplerFilter(string_view samplerFilter)
{
	if (samplerFilter == "nearest") return SamplerFilter::Nearest;
	if (samplerFilter == "linear") return SamplerFilter::Linear;
	throw runtime_error("Unknown sampler filter type. (" + string(samplerFilter) + ")");
}
/**
 * @brief Returns sampler filter name string.
 * @param samplerFilter target sampler filter type
 */
static string_view toString(SamplerFilter samplerFilter) noexcept
{
	GARDEN_ASSERT((uint8)samplerFilter < (uint8)SamplerFilter::Count);
	return samplerFilterNames[(psize)samplerFilter];
}

/**
 * @brief Returns shader stage name string.
 * @param samplerFilter target shader stage type
 */
static string_view toString(ShaderStage shaderStage) noexcept
{
	if (hasOneFlag(shaderStage, ShaderStage::Vertex)) return "Vertex";
	if (hasOneFlag(shaderStage, ShaderStage::Fragment)) return "Fragment";
	if (hasOneFlag(shaderStage, ShaderStage::Compute)) return "Compute";
	return "None";
}
/**
 * @brief Returns shader stage name list string.
 * @param samplerFilter target shader stage type
 */
static string toStringList(ShaderStage shaderStage) noexcept
{
	string list;
	if (hasAnyFlag(shaderStage, ShaderStage::None)) list += "None | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Vertex)) list += "Vertex | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Fragment)) list += "Fragment | ";
	if (hasAnyFlag(shaderStage, ShaderStage::Compute)) list += "Compute | ";
	if (list.length() >= 3) list.resize(list.length() - 3);
	return list;
}

#if GARDEN_DEBUG
/***********************************************************************************************************************
 * @brief Command buffer debug marker.
 * 
 * @details
 * Debug label is a tool used by developers to annotate resources, commands, and command groups with 
 * human-readable names or identifiers. These annotations do not affect the execution or performance 
 * of the application but serve as aids during the development and debugging process, making it easier 
 * to identify and troubleshoot issues within the complex flow of GPU operations.
 * 
 * @todo Add support of the queue labels.
 */
struct DebugLabel
{
	/**
	 * @brief Begins command buffer label region.
	 * 
	 * @param[in] name target region name
	 * @param color label color in the profiler
	 */
	static void begin(const string& name, Color color);
	/**
	 * @brief Ends command buffer label region.
	 * @note Do not forget to end all label regions.
	 */
	static void end();

	/**
	 * @brief Inserts debug label.
	 * 
	 * @param[in] name target label name
	 * @param color label color in the profiler
	 */
	static void insert(const string& name, Color color);

	/**
	 * @brief Creates and begins command buffer label region.
	 * 
	 * @param[in] name target region name
	 * @param color label color in the profiler
	 */
	DebugLabel(const string& name, const Color& color) { begin(name, color); }
	/**
	 * @brief Ends command buffer label region.
	 * @note Use { } to set multiple labels in the same function.
	 */
	~DebugLabel() { end(); }
};

/**
 * @brief Creates and begins command buffer label region. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define SET_GPU_DEBUG_LABEL(name, color) DebugLabel _debugLabel(name, color)
/**
 * @brief Inserts debug label. (Debug Only)
 * 
 * @param[in] name target label name
 * @param color label color in the profiler
 */
#define INSERT_GPU_DEBUG_LABEL(name, color) DebugLabel::insert(name, color)
/**
 * @brief Begins command buffer label region. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define BEGIN_GPU_DEBUG_LABEL(name, color) DebugLabel::begin(name, color)
/**
 * @brief Ends command buffer label region. (Debug Only)
 * @note Do not forget to end all label regions.
 */
#define END_GPU_DEBUG_LABEL() DebugLabel::end()
#else
/**
 * @brief Creates and begins command buffer label region. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define SET_GPU_DEBUG_LABEL(name, color) (void)0
/**
 * @brief Inserts debug label. (Debug Only)
 * 
 * @param[in] name target label name
 * @param color label color in the profiler
 */
#define INSERT_GPU_DEBUG_LABEL(name, color) (void)0
/**
 * @brief Begins command buffer label region. (Debug Only)
 * 
 * @param[in] name target region name
 * @param color label color in the profiler
 */
#define BEGIN_GPU_DEBUG_LABEL(name, color) (void)0
/**
 * @brief Ends command buffer label region. (Debug Only)
 * @note Do not forget to end all label regions.
 */
#define END_GPU_DEBUG_LABEL() (void)0
#endif

} // namespace garden::graphics