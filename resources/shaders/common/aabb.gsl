// Copyright 2022-2025 Nikita Fediuchin. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Axis Aligned Bounding Box

#ifndef AABB_GSL
#define AABB_GSL

#include "common/ray.gsl"
#include "common/math.gsl"

struct Aabb
{
	float3 min;
	float3 max;
};

//**********************************************************************************************************************
float2 raycast2I(Aabb aabb, Ray ray)
{
	float3 tBot = ray.direction * (aabb.min - ray.origin);
	float3 tTop = ray.direction * (aabb.max - ray.origin);
	float3 tMin = min(tTop, tBot); float3 tMax = max(tTop, tBot);
	float t0 = max(tMin.x, max(tMin.y, tMin.z));
	float t1 = min(tMax.x, min(tMax.y, tMax.z));
	return float2(t0, t1);
}
float2 raycast2(Aabb aabb, Ray ray)
{
	ray.direction = 1.0f / ray.direction;
	return raycast2I(aabb, ray);
}

float raycast1I(Aabb aabb, Ray ray)
{
	float3 tBot = ray.direction * (aabb.min - ray.origin);
	float3 tTop = ray.direction * (aabb.max - ray.origin);
	float3 tMin = min(tTop, tBot); float3 tMax = max(tTop, tBot);
	float t0 = max(tMin.x, max(tMin.y, tMin.z));
	float t1 = min(tMax.x, min(tMax.y, tMax.z));
	return t1 > max(t0, 0.0f) ? t0 : FLOAT32_MAX;
}
float raycast1(Aabb aabb, Ray ray)
{
	ray.direction = 1.0f / ray.direction;
	return raycast1I(aabb, ray);
}

bool isIntersected(float2 hitPoints)
{
	// If tMax < 0.0f, ray is intersecting AABB, but whole AABB is behing us.
	return hitPoints.y > max(hitPoints.x, 0.0f);
}

#endif // AABB_GSL